package mjava.problem;

public class UnsafeProblem {
    /**
     * Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。
     * 使用Unsafe几乎可以操作一切：
     *
     * （1）实例化一个类；
     *
     * （2）修改私有字段的值；
     *
     * （3）抛出checked异常；
     *
     * （4）使用堆外内存；
     *
     * （5）CAS操作；
     *      CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。
     *     否则，处理器不做任何操作。此操作是原子操作，可以看作一个小锁，当比较的时候其他线程无法操作，消耗很小
     *
     *      原子操作,就是”不可中断的一个或一系列操作”，原子操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）,不会被线程调度机制打断。
     *      首先处理器会自动保证基本的内存操作的原子操作。处理器保证从系统内存当中读取或者写入一个字节是不能被中断的
     *      在多进程（线程）访问共享资源时，能够确保所有其他的进程（线程）都不能在同一时间内访问相同的资源
     *
     *      首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，无法被中断，而其他处理器不能访问这个字节的内存地址。
     *      奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是  复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。
     *      但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。
     *
     *      在单核CPU中, 同一时间只能有一个线程运作，而且指令不可能被中断，所以只要禁止线程调度就能保证原子性
     *
     *      而在多核CPU中，仅仅禁用一个核的线程调度是不顶用的，当此时其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。
     *      所以引入了一条特殊的指令，当执行此指令时会阻塞其他cpu核对相关内存的缓存块的访问，只能由一个CPU进行操作。CAS就是被JVM转化为这一指令，同一时间只能由一个线程
     *      进行比较更新操作
     *
     *      CompareAndSwapXXX()方法。这种方式广泛运用于无锁算法，即时编译出来的结果就是一条平台相关的处理器CAS指令
     *      if(value == expect)
     *          value=newValue
     *      通过CPU的CAS指令可以保证这两步操作是一个整体，也就不会出现多线程环境中可能比较的时候value值是a，而到真正赋值的时候value值可能已经变成b了的问题
     *
     *
     * （6）阻塞/唤醒线程；
     */
}
