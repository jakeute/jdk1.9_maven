package mjava.util.concurrent;

/**
 * 跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表(链表需要有序)。
 * <p>
 * 跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。
 * <p>
 * 跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。
 * <p>
 * 为什么Redis选择使用跳表而不是红黑树来实现有序集合？
 * <p>
 * 首先，我们来分析下Redis的有序集合支持的操作：
 * <p>
 * 1）插入元素
 * <p>
 * 2）删除元素
 * <p>
 * 3）查找元素
 * <p>
 * 4）有序输出所有元素
 * <p>
 * 5）查找区间内所有元素
 * <p>
 * 如果使用数组实现 1 2 3的时间复杂度为n
 * 使用红黑树 跳表则是log n
 * 其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。
 * 但是，最后一项，红黑树的效率就没有跳表高了。
 * <p>
 * 在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。
 * <p>
 * 而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。
 * <p>
 * 此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。
 * <p>
 * ConcurrentSkipListMap要求key实现Comparable 或者传入key的comparator 来保持链表的有序性
 * <p>
 * 我们这里把整个插入过程分成三个部分：
 * <p>
 * Part I：找到目标节点的位置并插入
 * <p>
 * （1）这里的目标节点是数据节点，也就是最底层的那条链；
 * <p>
 * （2）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；查找操作从最顶层的节点向左向下查询
 * <p>
 * （3）从这个数据节点开始往后遍历，直到找到目标节点应该插入的位置；
 * <p>
 * （4）如果comp的结果为0，则说明key相等 就更新其值（onlyIfAbsent=false）；
 * <p>
 * （5）否则就把目标节点插入；
 * <p>
 * （6）至此，目标节点已经插入到最底层的数据节点链表中了；
 * <p>
 * Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引
 * <p>
 * （1）取个随机数rnd，计算(rnd & 0x80000001)；
 * <p>
 * （2）如果不等于0，结束插入过程，也就是不需要创建索引，返回；
 * <p>
 * （3）如果等于0，才进入创建索引的过程（只要正偶数才会等于0）；
 * <p>
 * （4）计算 while(((rnd>>>=1)&1)!=0)，决定层级数，level从1开始；
 * <p>
 * （5）如果算出来的层级不高于现有最高层级，则直接建立一条竖直的索引链表（只有down有值），并结束Part II；
 * <p>
 * （6）如果算出来的层级高于现有最高层级，则新的层级只能比现有最高层级多1；
 * <p>
 * （7）同样建立一条竖直的索引链表（只有down有值）；
 * <p>
 * （8）将头索引也向上增加到相应的高度，结束Part II；
 * <p>
 * （9）也就是说，如果层级不超过现有高度，只建立一条索引链，否则还要额外增加头索引链的高度（脑补一下，后面举例说明）；
 * <p>
 * Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起（补上right指针）
 * <p>
 * （1）从最高层级的头索引节点开始，向右遍历，找到目标索引节点的位置；
 * <p>
 * （2）如果当前层有目标索引，则把目标索引插入到这个位置，并把目标索引前一个索引向下移一个层级；
 * <p>
 * （3）如果当前层没有目标索引，则把目标索引位置前一个索引向下移一个层级；
 * <p>
 * （4）同样地，再向右遍历，寻找新的层级中目标索引的位置，回到第（2）步；
 * <p>
 * （5）依次循环找到所有层级目标索引的位置并把它们插入到横向的索引链表中；
 * <p>
 * 总结起来，一共就是三大步：
 * <p>
 * （1）插入目标节点到数据节点链表中；
 * <p>
 * （2）建立竖直的down链表；
 * <p>
 * （3）建立横向的right链表；
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * （1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；
 * <p>
 * （2）从这个数据节点开始往后遍历，直到找到目标节点的位置；
 * <p>
 * （3）如果这个位置没有元素，直接返回null，表示没有要删除的元素；
 * <p>
 * （4）如果这个位置有元素，先通过 n.casValue(v,null)原子更新把其value设置为null；
 * <p>
 * （5）通过 n.appendMarker(f)在当前元素后面添加一个marker元素标记当前元素是要删除的元素；
 * <p>
 * （6）通过 b.casNext(n,f)尝试删除元素；
 * <p>
 * （7）如果上面两步中的任意一步失败了都通过 findNode(key)中的 n.helpDelete(b,f)再去不断尝试删除；
 * <p>
 * （8）如果上面两步都成功了，再通过 findPredecessor(key,cmp)中的 q.unlink(r)删除索引节点；
 * <p>
 * （9）如果head的right指针指向了null，则跳表高度降级
 */
public class ConcurrentSkipListMapTest {
    public static void main(String[] args) {

    }
}
